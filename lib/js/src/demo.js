// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var $$Array    = require("bs-platform/lib/js/array.js");
var Block      = require("bs-platform/lib/js/block.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Random     = require("bs-platform/lib/js/random.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function makeWeights(length) {
  return $$Array.map((function () {
                return Random.$$float(1.0);
              }), Caml_array.caml_make_vect(length, 0.0));
}

function relu_000(inp) {
  return Math.log(1.0 + Math.exp(inp));
}

function relu_001(inp) {
  return 1.0 / (1.0 + Math.exp(-inp));
}

var relu = /* record */[
  relu_000,
  relu_001
];

function sum(arr) {
  return $$Array.fold_right((function (x, y) {
                return x + y;
              }), arr, 0.0);
}

function calcOutput(perc) {
  var match = perc[/* invalid */4];
  if (match !== 0) {
    perc[/* output */3] = Curry._1(perc[/* transfer */5][/* func */0], $$Array.fold_right((function (x, y) {
                return x + y;
              }), $$Array.mapi((function (ind, inputNode) {
                    if (inputNode.tag) {
                      return inputNode[0] * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    } else {
                      return calcOutput(inputNode[0]) * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    }
                  }), perc[/* inputNodes */0]), 0.0));
    perc[/* invalid */4] = /* false */0;
    var match$1 = perc[/* outputNodes */1];
    if (match$1.tag) {
      perc[/* outputNodes */1] = /* Output */Block.__(1, [perc[/* output */3]]);
    }
    return perc[/* output */3];
  } else {
    return perc[/* output */3];
  }
}

function makePerceptron(inputs) {
  var perc = /* record */[
    /* inputNodes */$$Array.append(inputs, /* array */[/* Input */Block.__(1, [1.0])]),
    /* outputNodes : Output */Block.__(1, [0.0]),
    /* weights */makeWeights(inputs.length + 1 | 0),
    /* output */0.0,
    /* invalid : true */1,
    /* transfer */relu
  ];
  $$Array.map((function (thisPerc) {
          if (thisPerc.tag) {
            return /* () */0;
          } else {
            var thisThisPerc = thisPerc[0];
            var match = thisThisPerc[/* outputNodes */1];
            var tmp;
            tmp = match.tag ? /* Perceptrons */Block.__(0, [/* array */[perc]]) : /* Perceptrons */Block.__(0, [$$Array.append(match[0], /* array */[perc])]);
            thisThisPerc[/* outputNodes */1] = tmp;
            return /* () */0;
          }
        }), inputs);
  return perc;
}

function makeNetworkRecursive(_shape, _net) {
  while(true) {
    var net = _net;
    var shape = _shape;
    var inputs;
    if (net) {
      var net$1 = net[0];
      inputs = $$Array.map((function (perc) {
              return /* Perceptron */Block.__(0, [perc]);
            }), Caml_array.caml_array_get(net$1, net$1.length - 1 | 0));
    } else {
      inputs = Caml_array.caml_make_vect(List.hd(shape), /* Input */Block.__(1, [0.0]));
    }
    var existing = net ? net[0] : /* array */[];
    if (shape) {
      _net = /* Some */[$$Array.append(existing, /* array */[$$Array.map((function(inputs){
                  return function () {
                    return makePerceptron(inputs);
                  }
                  }(inputs)), Caml_array.caml_make_vect(shape[0], 0))])];
      _shape = shape[1];
      continue ;
      
    } else {
      return existing;
    }
  };
}

function makeNetwork(shape) {
  return makeNetworkRecursive(shape, /* None */0);
}

function calcOutput$1(net) {
  var outputLayer = Caml_array.caml_array_get(net, net.length - 1 | 0);
  return $$Array.map(calcOutput, outputLayer);
}

function setInputs(net, inputs) {
  var inputLayer = Caml_array.caml_array_get(net, 0);
  $$Array.map((function (perc) {
          perc[/* inputNodes */0] = inputs;
          return /* () */0;
        }), inputLayer);
  $$Array.map((function (layer) {
          return $$Array.map((function (perc) {
                        perc[/* invalid */4] = /* true */1;
                        return /* () */0;
                      }), layer);
        }), net);
  return net;
}

function calcError(net, expectedOutput) {
  var outputs = calcOutput$1(net);
  return 0.5 * sum($$Array.mapi((function (ind, output) {
                    return Math.pow(Caml_array.caml_array_get(expectedOutput, ind) - output, 2.0);
                  }), outputs));
}

function logOutput(net) {
  console.log("Inputs");
  $$Array.map((function (inputNode) {
          if (inputNode.tag) {
            console.log(inputNode[0]);
            return /* () */0;
          } else {
            console.log("Perceptron");
            return /* () */0;
          }
        }), Caml_array.caml_array_get(Caml_array.caml_array_get(net, 0), 0)[/* inputNodes */0]);
  return $$Array.mapi((function (ind, layer) {
                console.log("Layer " + Pervasives.string_of_int(ind));
                return $$Array.map((function (perc) {
                              console.log(perc[/* output */3]);
                              return /* () */0;
                            }), layer);
              }), net);
}

function backProp(net, expectedOutput) {
  var reversed = $$Array.of_list(List.rev($$Array.to_list(net)));
  var outputLayer = Caml_array.caml_array_get(reversed, 0);
  return $$Array.mapi((function (ind, perc) {
                var dEdO = perc[/* output */3] - Caml_array.caml_array_get(expectedOutput, ind);
                var dOdN = Curry._1(perc[/* transfer */5][/* deriv */1], perc[/* output */3]);
                return $$Array.map((function (input) {
                              var tmp;
                              tmp = input.tag ? input[0] : input[0][/* output */3];
                              return dEdO * dOdN * tmp;
                            }), perc[/* inputNodes */0]);
              }), outputLayer);
}

var z = makeNetworkRecursive(/* :: */[
      2,
      /* :: */[
        3,
        /* :: */[
          2,
          /* [] */0
        ]
      ]
    ], /* None */0);

setInputs(z, /* array */[
      /* Input */Block.__(1, [0.4]),
      /* Input */Block.__(1, [0.2])
    ]);

calcOutput$1(z);

logOutput(z);

console.log("===============");

console.log(calcError(z, /* float array */[
          3.5,
          2.9
        ]));

exports.makeWeights          = makeWeights;
exports.relu                 = relu;
exports.sum                  = sum;
exports.makePerceptron       = makePerceptron;
exports.makeNetworkRecursive = makeNetworkRecursive;
exports.makeNetwork          = makeNetwork;
exports.calcOutput           = calcOutput$1;
exports.setInputs            = setInputs;
exports.calcError            = calcError;
exports.logOutput            = logOutput;
exports.backProp             = backProp;
exports.z                    = z;
/* z Not a pure module */

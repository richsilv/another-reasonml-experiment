// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List            = require("bs-platform/lib/js/list.js");
var $$Array         = require("bs-platform/lib/js/array.js");
var Block           = require("bs-platform/lib/js/block.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Random          = require("bs-platform/lib/js/random.js");
var Caml_array      = require("bs-platform/lib/js/caml_array.js");
var Pervasives      = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var seed = (parseInt(Math.random() * Number.MAX_SAFE_INTEGER));

Random.init(seed);

function makeWeights(length) {
  return $$Array.map((function () {
                return Random.$$float(1.0);
              }), Caml_array.caml_make_vect(length, 0.0));
}

function relu_000(inp) {
  return Math.log(1.0 + Math.exp(inp));
}

function relu_001(inp) {
  return 1.0 / (1.0 + Math.exp(-inp));
}

var relu = /* record */[
  relu_000,
  relu_001
];

function sum(arr) {
  return $$Array.fold_right((function (x, y) {
                return x + y;
              }), arr, 0.0);
}

function calcOutput(perc) {
  var match = perc[/* invalid */4];
  if (match !== 0) {
    perc[/* output */3] = Curry._1(perc[/* transfer */6][/* func */0], $$Array.fold_right((function (x, y) {
                return x + y;
              }), $$Array.mapi((function (ind, inputNode) {
                    if (inputNode.tag) {
                      return inputNode[0] * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    } else {
                      return calcOutput(inputNode[0]) * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    }
                  }), perc[/* inputNodes */0]), 0.0));
    perc[/* invalid */4] = /* false */0;
    var match$1 = perc[/* outputNodes */1];
    if (match$1.tag) {
      perc[/* outputNodes */1] = /* Output */Block.__(1, [perc[/* output */3]]);
    }
    return perc[/* output */3];
  } else {
    return perc[/* output */3];
  }
}

function makePerceptron(inputs) {
  var perc = /* record */[
    /* inputNodes */$$Array.append(inputs, /* array */[/* Input */Block.__(1, [1.0])]),
    /* outputNodes : Output */Block.__(1, [0.0]),
    /* weights */makeWeights(inputs.length + 1 | 0),
    /* output */0.0,
    /* invalid : true */1,
    /* dEdN */0.0,
    /* transfer */relu
  ];
  $$Array.iter((function (thisPerc) {
          if (thisPerc.tag) {
            return /* () */0;
          } else {
            var thisThisPerc = thisPerc[0];
            var match = thisThisPerc[/* outputNodes */1];
            var tmp;
            tmp = match.tag ? /* Perceptrons */Block.__(0, [/* array */[perc]]) : /* Perceptrons */Block.__(0, [$$Array.append(match[0], /* array */[perc])]);
            thisThisPerc[/* outputNodes */1] = tmp;
            return /* () */0;
          }
        }), inputs);
  return perc;
}

function recursivelyMakeNetwork(_shape, _net) {
  while(true) {
    var net = _net;
    var shape = _shape;
    var inputs;
    if (net) {
      var net$1 = net[0];
      inputs = $$Array.map((function (perc) {
              return /* Perceptron */Block.__(0, [perc]);
            }), Caml_array.caml_array_get(net$1, net$1.length - 1 | 0));
    } else {
      inputs = Caml_array.caml_make_vect(List.hd(shape), /* Input */Block.__(1, [0.0]));
    }
    var existing = net ? net[0] : /* array */[];
    if (shape) {
      _net = /* Some */[$$Array.append(existing, /* array */[$$Array.map((function(inputs){
                  return function () {
                    return makePerceptron(inputs);
                  }
                  }(inputs)), Caml_array.caml_make_vect(shape[0], 0))])];
      _shape = shape[1];
      continue ;
      
    } else {
      return existing;
    }
  };
}

function makeNetwork(shape) {
  return recursivelyMakeNetwork(shape, /* None */0);
}

function calcOutput$1(net) {
  var outputLayer = Caml_array.caml_array_get(net, net.length - 1 | 0);
  return $$Array.map(calcOutput, outputLayer);
}

function setInputs(net, inputs) {
  var inputLayer = Caml_array.caml_array_get(net, 0);
  $$Array.iter((function (perc) {
          perc[/* inputNodes */0] = inputs;
          if ($$Array.fold_right((function (input, allFloats) {
                    return input.tag ? allFloats : /* false */0;
                  }), inputs, /* true */1)) {
            $$Array.map((function (perc) {
                    perc[/* weights */2] = $$Array.sub(perc[/* weights */2], 0, inputs.length);
                    return /* () */0;
                  }), inputLayer);
            return /* () */0;
          } else {
            console.log("WARNING - you are connecting perceptrons rather than values as network inputs");
            return /* () */0;
          }
        }), inputLayer);
  $$Array.iter((function (layer) {
          return $$Array.iter((function (perc) {
                        perc[/* invalid */4] = /* true */1;
                        return /* () */0;
                      }), layer);
        }), net);
  return net;
}

var WrongNodeType = Caml_exceptions.create("Demo-MyFirstApp.WrongNodeType");

function calcError(net, expectedOutput) {
  var outputs = calcOutput$1(net);
  return 0.5 * sum($$Array.mapi((function (ind, thisOutput) {
                    if (thisOutput.tag) {
                      return Math.pow(thisOutput[0] - Caml_array.caml_array_get(outputs, ind), 2.0);
                    } else {
                      throw [
                            WrongNodeType,
                            "Perceptron"
                          ];
                    }
                  }), expectedOutput));
}

function logOutput(net) {
  console.log("Inputs");
  $$Array.iter((function (inputNode) {
          if (inputNode.tag) {
            console.log(inputNode[0]);
            return /* () */0;
          } else {
            console.log("Perceptron");
            return /* () */0;
          }
        }), Caml_array.caml_array_get(Caml_array.caml_array_get(net, 0), 0)[/* inputNodes */0]);
  return $$Array.mapi((function (ind, layer) {
                console.log("Layer " + Pervasives.string_of_int(ind));
                return $$Array.map((function (perc) {
                              console.log(perc[/* output */3]);
                              return /* () */0;
                            }), layer);
              }), net);
}

function logWeights(net) {
  $$Array.mapi((function (ind, layer) {
          console.log("Layer " + Pervasives.string_of_int(ind));
          return $$Array.map((function (perc) {
                        console.log(perc[/* weights */2]);
                        return /* () */0;
                      }), layer);
        }), net);
  return /* () */0;
}

var DimensionMismatch = Caml_exceptions.create("Demo-MyFirstApp.DimensionMismatch");

function linearAdd(a, b) {
  if (a.tag) {
    if (b.tag) {
      var n = b[0];
      return /* Matrix */Block.__(1, [$$Array.mapi((function (ind, entry) {
                        return linearAdd(entry, Caml_array.caml_array_get(n, ind));
                      }), a[0])]);
    } else {
      throw [
            DimensionMismatch,
            "Objects do not have the same dimensions"
          ];
    }
  } else {
    var u = a[0];
    if (b.tag) {
      throw [
            DimensionMismatch,
            "Objects do not have the same dimensions"
          ];
    } else {
      return /* Vector */Block.__(0, [$$Array.mapi((function (ind, entry) {
                        return entry + Caml_array.caml_array_get(u, ind);
                      }), b[0])]);
    }
  }
}

function sumDerivs(derivs) {
  return List.fold_right(linearAdd, List.tl(derivs), List.hd(derivs));
}

function errorDerivs(net, expectedOutput) {
  var reversed = $$Array.of_list(List.rev($$Array.to_list(net)));
  return /* Matrix */Block.__(1, [$$Array.of_list(List.rev($$Array.to_list($$Array.map((function (layer) {
                                return /* Matrix */Block.__(1, [$$Array.mapi((function (ind, perc) {
                                                  var match = perc[/* outputNodes */1];
                                                  var dEdO;
                                                  if (match.tag) {
                                                    var thisExpectedOutput = Caml_array.caml_array_get(expectedOutput, ind);
                                                    if (thisExpectedOutput.tag) {
                                                      dEdO = match[0] - thisExpectedOutput[0];
                                                    } else {
                                                      throw [
                                                            WrongNodeType,
                                                            "Perceptron"
                                                          ];
                                                    }
                                                  } else {
                                                    dEdO = sum($$Array.mapi((function (innerInd, innerPerc) {
                                                                return innerPerc[/* dEdN */5] * Caml_array.caml_array_get(innerPerc[/* weights */2], innerInd);
                                                              }), match[0]));
                                                  }
                                                  var dOdN = Curry._1(perc[/* transfer */6][/* deriv */1], perc[/* output */3]);
                                                  perc[/* dEdN */5] = dEdO * dOdN;
                                                  return /* Vector */Block.__(0, [$$Array.map((function (input) {
                                                                    var tmp;
                                                                    tmp = input.tag ? input[0] : input[0][/* output */3];
                                                                    return perc[/* dEdN */5] * tmp;
                                                                  }), perc[/* inputNodes */0])]);
                                                }), layer)]);
                              }), reversed))))]);
}

function updateWeights(net, errorDerivs, alpha) {
  if (errorDerivs.tag) {
    $$Array.mapi((function (indA, layer) {
            if (layer.tag) {
              $$Array.mapi((function (indB, percEntry) {
                      if (percEntry.tag) {
                        throw [
                              DimensionMismatch,
                              "Object does not have the right number of dimensions"
                            ];
                      } else {
                        $$Array.mapi((function (indC, weightError) {
                                var perc = Caml_array.caml_array_get(Caml_array.caml_array_get(net, indA), indB);
                                var currentWeight = Caml_array.caml_array_get(perc[/* weights */2], indC);
                                Caml_array.caml_array_set(perc[/* weights */2], indC, currentWeight - alpha * weightError);
                                var match = perc[/* outputNodes */1];
                                if (match.tag) {
                                  return /* () */0;
                                } else {
                                  $$Array.map((function (outputPerc) {
                                          outputPerc[/* invalid */4] = /* true */1;
                                          return /* () */0;
                                        }), match[0]);
                                  return /* () */0;
                                }
                              }), percEntry[0]);
                        return /* () */0;
                      }
                    }), layer[0]);
              return /* () */0;
            } else {
              throw [
                    DimensionMismatch,
                    "Object does not have the right number of dimensions"
                  ];
            }
          }), errorDerivs[0]);
    return /* () */0;
  } else {
    throw [
          DimensionMismatch,
          "Object does not have the right number of dimensions"
        ];
  }
}

function sample(min, max) {
  return Random.$$float(max - min) + min;
}

function makeSingleValFunctionData(f, min, max, number) {
  var examples = /* [] */0;
  for(var _for = 0; _for <= number; ++_for){
    var input = sample(min, max);
    examples = /* :: */[
      /* tuple */[
        /* array */[/* Input */Block.__(1, [input])],
        /* array */[/* Output */Block.__(1, [Curry._1(f, input)])]
      ],
      examples
    ];
  }
  return examples;
}

function trainExample(net, errorData, example) {
  var outputs = example[1];
  setInputs(net, example[0]);
  calcOutput$1(net);
  var error = calcError(net, outputs);
  var derivs = errorDerivs(net, outputs);
  if (errorData) {
    var errorDataSoFar = errorData[0];
    return /* tuple */[
            linearAdd(errorDataSoFar[0], derivs),
            error + errorDataSoFar[1]
          ];
  } else {
    return /* tuple */[
            derivs,
            error
          ];
  }
}

function trainEpoch(net, data, alpha) {
  var errorData = List.fold_left((function (errorSoFar, example) {
          return /* Some */[trainExample(net, errorSoFar, example)];
        }), /* None */0, data);
  if (errorData) {
    var errorData$1 = errorData[0];
    updateWeights(net, errorData$1[0], alpha);
    return errorData$1[1];
  } else {
    return 0.0;
  }
}

var myNet = recursivelyMakeNetwork(/* :: */[
      5,
      /* :: */[
        5,
        /* :: */[
          1,
          /* [] */0
        ]
      ]
    ], /* None */0);

var data = makeSingleValFunctionData((function (inp) {
        return Math.abs(Math.sin(inp));
      }), -5.0, 5.0, 100);

console.log(trainEpoch(myNet, data, 0.001));

console.log(trainEpoch(myNet, data, 0.001));

console.log(trainEpoch(myNet, data, 0.001));

console.log(trainEpoch(myNet, data, 0.001));

console.log(trainEpoch(myNet, data, 0.001));

exports.seed                      = seed;
exports.makeWeights               = makeWeights;
exports.relu                      = relu;
exports.sum                       = sum;
exports.makePerceptron            = makePerceptron;
exports.recursivelyMakeNetwork    = recursivelyMakeNetwork;
exports.makeNetwork               = makeNetwork;
exports.calcOutput                = calcOutput$1;
exports.setInputs                 = setInputs;
exports.WrongNodeType             = WrongNodeType;
exports.calcError                 = calcError;
exports.logOutput                 = logOutput;
exports.logWeights                = logWeights;
exports.DimensionMismatch         = DimensionMismatch;
exports.linearAdd                 = linearAdd;
exports.sumDerivs                 = sumDerivs;
exports.errorDerivs               = errorDerivs;
exports.updateWeights             = updateWeights;
exports.sample                    = sample;
exports.makeSingleValFunctionData = makeSingleValFunctionData;
exports.trainExample              = trainExample;
exports.trainEpoch                = trainEpoch;
exports.myNet                     = myNet;
exports.data                      = data;
/* seed Not a pure module */

// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List            = require("bs-platform/lib/js/list.js");
var $$Array         = require("bs-platform/lib/js/array.js");
var Block           = require("bs-platform/lib/js/block.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Random          = require("bs-platform/lib/js/random.js");
var Caml_array      = require("bs-platform/lib/js/caml_array.js");
var Caml_float      = require("bs-platform/lib/js/caml_float.js");
var Caml_int32      = require("bs-platform/lib/js/caml_int32.js");
var Pervasives      = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var seed = (parseInt(Math.random() * Number.MAX_SAFE_INTEGER));

Random.init(seed);

function makeWeights(length) {
  return $$Array.map((function () {
                return Random.$$float(1.0);
              }), Caml_array.caml_make_vect(length, 0.0));
}

function softplus_000(inp) {
  if (inp > 32.0) {
    return inp;
  } else {
    return Math.log(1.0 + Math.exp(inp));
  }
}

function softplus_001(inp) {
  return 1.0 / (1.0 + Math.exp(-inp));
}

var softplus = /* record */[
  softplus_000,
  softplus_001
];

function relu_000(inp) {
  if (inp >= 0.0) {
    return inp;
  } else {
    return 0.01 * inp;
  }
}

function relu_001(inp) {
  if (inp >= 0.0) {
    return 1.0;
  } else {
    return 0.01;
  }
}

var relu = /* record */[
  relu_000,
  relu_001
];

function linear_000(inp) {
  return inp;
}

function linear_001() {
  return 1.0;
}

var linear = /* record */[
  linear_000,
  linear_001
];

function tanhAct_000(inp) {
  return Math.tanh(inp);
}

function tanhAct_001(inp) {
  return 1.0 - Math.pow(Math.tanh(inp), 2.0);
}

var tanhAct = /* record */[
  tanhAct_000,
  tanhAct_001
];

function sum(arr) {
  return $$Array.fold_right((function (x, y) {
                return x + y;
              }), arr, 0.0);
}

function calcOutput(perc) {
  var match = perc[/* invalid */4];
  if (match !== 0) {
    var n = $$Array.fold_right((function (x, y) {
            return x + y;
          }), $$Array.mapi((function (ind, inputNode) {
                if (inputNode.tag) {
                  return inputNode[0] * Caml_array.caml_array_get(perc[/* weights */2], ind);
                } else {
                  return calcOutput(inputNode[0]) * Caml_array.caml_array_get(perc[/* weights */2], ind);
                }
              }), perc[/* inputNodes */0]), 0.0);
    perc[/* output */3] = Curry._1(perc[/* transfer */6][/* func */0], n);
    perc[/* invalid */4] = /* false */0;
    var match$1 = perc[/* outputNodes */1];
    if (match$1.tag) {
      perc[/* outputNodes */1] = /* Output */Block.__(1, [perc[/* output */3]]);
    }
    return perc[/* output */3];
  } else {
    return perc[/* output */3];
  }
}

function makePerceptron(inputs, transfer) {
  var perc = /* record */[
    /* inputNodes */$$Array.append(inputs, /* array */[/* Input */Block.__(1, [1.0])]),
    /* outputNodes : Output */Block.__(1, [0.0]),
    /* weights */makeWeights(inputs.length + 1 | 0),
    /* output */0.0,
    /* invalid : true */1,
    /* dEdN */0.0,
    /* transfer */transfer
  ];
  $$Array.iter((function (thisPerc) {
          if (thisPerc.tag) {
            return /* () */0;
          } else {
            var thisThisPerc = thisPerc[0];
            var match = thisThisPerc[/* outputNodes */1];
            var tmp;
            tmp = match.tag ? /* Perceptrons */Block.__(0, [/* array */[perc]]) : /* Perceptrons */Block.__(0, [$$Array.append(match[0], /* array */[perc])]);
            thisThisPerc[/* outputNodes */1] = tmp;
            return /* () */0;
          }
        }), inputs);
  return perc;
}

function recursivelyMakePerceptrons(_, transfer, _shape, _perceptrons) {
  while(true) {
    var perceptrons = _perceptrons;
    var shape = _shape;
    var inputs;
    if (perceptrons) {
      var perceptrons$1 = perceptrons[0];
      inputs = $$Array.map((function (perc) {
              return /* Perceptron */Block.__(0, [perc]);
            }), Caml_array.caml_array_get(perceptrons$1, perceptrons$1.length - 1 | 0));
    } else {
      inputs = Caml_array.caml_make_vect(List.hd(shape), /* Input */Block.__(1, [0.0]));
    }
    var existing = perceptrons ? perceptrons[0] : /* array */[];
    if (shape) {
      _perceptrons = /* Some */[$$Array.append(existing, /* array */[$$Array.map((function(inputs){
                  return function () {
                    return makePerceptron(inputs, transfer);
                  }
                  }(inputs)), Caml_array.caml_make_vect(shape[0], 0))])];
      _shape = shape[1];
      continue ;
      
    } else {
      return existing;
    }
  };
}

function makeNetwork(config, tranfer, shape) {
  return /* record */[
          /* perceptrons */recursivelyMakePerceptrons(config, tranfer, shape, /* None */0),
          /* config */config,
          /* velocity : None */0,
          /* error */Pervasives.infinity
        ];
}

function calcOutput$1(net) {
  var outputLayer = Caml_array.caml_array_get(net[/* perceptrons */0], net[/* perceptrons */0].length - 1 | 0);
  return $$Array.map(calcOutput, outputLayer);
}

function setInputs(net, inputs) {
  var inputLayer = Caml_array.caml_array_get(net[/* perceptrons */0], 0);
  $$Array.iter((function (perc) {
          perc[/* inputNodes */0] = inputs;
          if ($$Array.fold_right((function (input, allFloats) {
                    return input.tag ? allFloats : /* false */0;
                  }), inputs, /* true */1)) {
            $$Array.map((function (perc) {
                    perc[/* weights */2] = $$Array.sub(perc[/* weights */2], 0, inputs.length);
                    return /* () */0;
                  }), inputLayer);
            return /* () */0;
          } else {
            return Pervasives.print_string("WARNING - you are connecting perceptrons rather than values as network inputs");
          }
        }), inputLayer);
  $$Array.iter((function (layer) {
          return $$Array.iter((function (perc) {
                        perc[/* invalid */4] = /* true */1;
                        return /* () */0;
                      }), layer);
        }), net[/* perceptrons */0]);
  return net;
}

var WrongNodeType = Caml_exceptions.create("Demo-MyFirstApp.WrongNodeType");

function calcError(net, expectedOutput) {
  var outputs = calcOutput$1(net);
  return 0.5 * sum($$Array.mapi((function (ind, thisOutput) {
                    if (thisOutput.tag) {
                      return Math.pow(thisOutput[0] - Caml_array.caml_array_get(outputs, ind), 2.0);
                    } else {
                      throw [
                            WrongNodeType,
                            "Perceptron"
                          ];
                    }
                  }), expectedOutput));
}

function logOutput(net) {
  Pervasives.print_string("Inputs");
  $$Array.iter((function (inputNode) {
          if (inputNode.tag) {
            return Pervasives.print_float(inputNode[0]);
          } else {
            return Pervasives.print_string("Perceptron");
          }
        }), Caml_array.caml_array_get(Caml_array.caml_array_get(net[/* perceptrons */0], 0), 0)[/* inputNodes */0]);
  return $$Array.mapi((function (ind, layer) {
                Pervasives.print_string("Layer " + Pervasives.string_of_int(ind));
                return $$Array.map((function (perc) {
                              return Pervasives.print_float(perc[/* output */3]);
                            }), layer);
              }), net[/* perceptrons */0]);
}

function logWeights(net) {
  $$Array.mapi((function (ind, layer) {
          console.log("Layer " + Pervasives.string_of_int(ind));
          return $$Array.map((function (perc) {
                        console.log(perc[/* weights */2]);
                        return /* () */0;
                      }), layer);
        }), net[/* perceptrons */0]);
  return /* () */0;
}

var DimensionMismatch = Caml_exceptions.create("Demo-MyFirstApp.DimensionMismatch");

function leftPad(s, indent) {
  var retString = s;
  for(var _for = 0; _for <= indent; ++_for){
    retString = " " + retString;
  }
  return retString;
}

function logLinearObj(obj, indent) {
  if (obj.tag) {
    return $$Array.iteri((function (ind, innerObj) {
                  console.log(leftPad(Pervasives.string_of_int(ind), indent));
                  return logLinearObj(innerObj, indent + 2 | 0);
                }), obj[0]);
  } else {
    console.log(leftPad($$Array.fold_left((function (output, x) {
                    return output + " " + Pervasives.string_of_float(x);
                  }), leftPad("", indent), obj[0]), indent));
    return /* () */0;
  }
}

function linearAdd(a, b) {
  if (a.tag) {
    if (b.tag) {
      var n = b[0];
      return /* Matrix */Block.__(1, [$$Array.mapi((function (ind, entry) {
                        return linearAdd(entry, Caml_array.caml_array_get(n, ind));
                      }), a[0])]);
    } else {
      throw [
            DimensionMismatch,
            "Objects do not have the same dimensions"
          ];
    }
  } else {
    var u = a[0];
    if (b.tag) {
      throw [
            DimensionMismatch,
            "Objects do not have the same dimensions"
          ];
    } else {
      return /* Vector */Block.__(0, [$$Array.mapi((function (ind, entry) {
                        return entry + Caml_array.caml_array_get(u, ind);
                      }), b[0])]);
    }
  }
}

function linearScalarProd(a, p) {
  if (a.tag) {
    return /* Matrix */Block.__(1, [$$Array.map((function (entry) {
                      return linearScalarProd(entry, p);
                    }), a[0])]);
  } else {
    return /* Vector */Block.__(0, [$$Array.map((function (entry) {
                      return entry * p;
                    }), a[0])]);
  }
}

function linearClip(clipLimit, obj) {
  if (obj.tag) {
    return /* Matrix */Block.__(1, [$$Array.map((function (param) {
                      return linearClip(clipLimit, param);
                    }), obj[0])]);
  } else {
    return /* Vector */Block.__(0, [$$Array.map((function (x) {
                      return Caml_float.caml_copysign_float(Pervasives.min(clipLimit, Math.abs(x)), x);
                    }), obj[0])]);
  }
}

function sumDerivs(derivs) {
  return List.fold_right(linearAdd, List.tl(derivs), List.hd(derivs));
}

function errorDerivs(net, expectedOutput) {
  var reversed = $$Array.of_list(List.rev($$Array.to_list(net[/* perceptrons */0])));
  return /* Matrix */Block.__(1, [$$Array.of_list(List.rev($$Array.to_list($$Array.map((function (layer) {
                                return /* Matrix */Block.__(1, [$$Array.mapi((function (ind, thisPerc) {
                                                  var match = thisPerc[/* outputNodes */1];
                                                  var dEdO;
                                                  if (match.tag) {
                                                    var thisExpectedOutput = Caml_array.caml_array_get(expectedOutput, ind);
                                                    if (thisExpectedOutput.tag) {
                                                      dEdO = match[0] - thisExpectedOutput[0];
                                                    } else {
                                                      throw [
                                                            WrongNodeType,
                                                            "Perceptron"
                                                          ];
                                                    }
                                                  } else {
                                                    dEdO = sum($$Array.map((function (outputPerc) {
                                                                return outputPerc[/* dEdN */5] * Caml_array.caml_array_get(outputPerc[/* weights */2], ind);
                                                              }), match[0]));
                                                  }
                                                  var dOdN = Curry._1(thisPerc[/* transfer */6][/* deriv */1], thisPerc[/* output */3]);
                                                  thisPerc[/* dEdN */5] = dEdO * dOdN;
                                                  return /* Vector */Block.__(0, [$$Array.map((function (inputNode) {
                                                                    var tmp;
                                                                    tmp = inputNode.tag ? inputNode[0] : inputNode[0][/* output */3];
                                                                    return thisPerc[/* dEdN */5] * tmp;
                                                                  }), thisPerc[/* inputNodes */0])]);
                                                }), layer)]);
                              }), reversed))))]);
}

function updateWeights(net, velocity) {
  if (velocity.tag) {
    $$Array.mapi((function (indA, layer) {
            if (layer.tag) {
              $$Array.mapi((function (indB, percEntry) {
                      if (percEntry.tag) {
                        throw [
                              DimensionMismatch,
                              "Object does not have the right number of dimensions"
                            ];
                      } else {
                        $$Array.mapi((function (indC, weightUpdate) {
                                var perc = Caml_array.caml_array_get(Caml_array.caml_array_get(net[/* perceptrons */0], indA), indB);
                                var currentWeight = Caml_array.caml_array_get(perc[/* weights */2], indC);
                                Caml_array.caml_array_set(perc[/* weights */2], indC, currentWeight - weightUpdate);
                                var match = perc[/* outputNodes */1];
                                if (match.tag) {
                                  return /* () */0;
                                } else {
                                  $$Array.map((function (outputPerc) {
                                          outputPerc[/* invalid */4] = /* true */1;
                                          return /* () */0;
                                        }), match[0]);
                                  return /* () */0;
                                }
                              }), percEntry[0]);
                        return /* () */0;
                      }
                    }), layer[0]);
              return /* () */0;
            } else {
              throw [
                    DimensionMismatch,
                    "Object does not have the right number of dimensions"
                  ];
            }
          }), velocity[0]);
  } else {
    throw [
          DimensionMismatch,
          "Object does not have the right number of dimensions"
        ];
  }
  net[/* velocity */2] = /* Some */[velocity];
  return /* () */0;
}

function sample(min, max) {
  return Random.$$float(max - min) + min;
}

function makeSingleValFunctionData(f, min, max, number) {
  var examples = /* [] */0;
  for(var _for = 0; _for <= number; ++_for){
    var input = sample(min, max);
    examples = /* :: */[
      /* tuple */[
        /* array */[/* Input */Block.__(1, [input])],
        /* array */[/* Output */Block.__(1, [Curry._1(f, input)])]
      ],
      examples
    ];
  }
  return examples;
}

function trainExample(net, errorData, example) {
  var outputs = example[1];
  setInputs(net, example[0]);
  calcOutput$1(net);
  var error = calcError(net, outputs);
  var derivs = errorDerivs(net, outputs);
  if (errorData) {
    var errorDataSoFar = errorData[0];
    return /* tuple */[
            linearAdd(errorDataSoFar[0], derivs),
            error + errorDataSoFar[1]
          ];
  } else {
    return /* tuple */[
            derivs,
            error
          ];
  }
}

function shuffleArray(a) {
  var b = $$Array.copy(a);
  $$Array.fast_sort((function (_, _$1) {
          return Random.$$int(2) - 1 | 0;
        }), b);
  return b;
}

function trainMiniBatch(net, data) {
  var errorData = List.fold_left((function (errorSoFar, example) {
          return /* Some */[trainExample(net, errorSoFar, example)];
        }), /* None */0, data);
  if (errorData) {
    var errorData$1 = errorData[0];
    var weightDerivs = errorData$1[0];
    var match = net[/* velocity */2];
    var newVelocity = match ? linearClip(net[/* config */1][/* gradientClip */1], linearAdd(linearScalarProd(match[0], net[/* config */1][/* gamma */4]), linearScalarProd(weightDerivs, (1.0 - net[/* config */1][/* gamma */4]) * net[/* config */1][/* alpha */8] / net[/* config */1][/* batchSize */5]))) : linearClip(net[/* config */1][/* gradientClip */1], linearScalarProd(weightDerivs, net[/* config */1][/* alpha */8]));
    updateWeights(net, newVelocity);
    return errorData$1[1];
  } else {
    return 0.0;
  }
}

function trainEpoch(net, data) {
  var match = net[/* config */1][/* shuffle */0];
  var finalDataArray = match !== 0 ? shuffleArray($$Array.of_list(data)) : $$Array.of_list(data);
  var dataLength = finalDataArray.length;
  var match$1 = net[/* config */1][/* batchSize */5];
  var miniBatchSize = match$1 !== 0 ? net[/* config */1][/* batchSize */5] : dataLength;
  var match$2 = $$Array.fold_left((function (iterDetails, _) {
          var lastIndex = iterDetails[1];
          var thisBatchSize = Pervasives.min(miniBatchSize, dataLength - lastIndex | 0);
          var thisError = trainMiniBatch(net, $$Array.to_list($$Array.sub(finalDataArray, lastIndex, thisBatchSize)));
          var newError = iterDetails[0] + thisError;
          return /* tuple */[
                  newError,
                  lastIndex + thisBatchSize | 0
                ];
        }), /* tuple */[
        0.0,
        0
      ], Caml_array.caml_make_vect(1 + Caml_int32.div(dataLength, miniBatchSize) | 0, 0));
  var error = match$2[0];
  if (error < net[/* error */3]) {
    net[/* config */1][/* alpha */8] = net[/* config */1][/* alpha */8] * net[/* config */1][/* decreasedErrorAlpha */6];
  } else {
    net[/* config */1][/* alpha */8] = net[/* config */1][/* alpha */8] * net[/* config */1][/* increasedErrorAlpha */7];
  }
  net[/* error */3] = error;
  return error;
}

function setLayerTransfer(net, layerInd, transfer) {
  $$Array.map((function (perc) {
          perc[/* transfer */6] = transfer;
          return /* () */0;
        }), Caml_array.caml_array_get(net[/* perceptrons */0], layerInd));
  return /* () */0;
}

function trainNetwork(net, data) {
  var error = net[/* config */1][/* targetError */3] + 1.0;
  var epochs = 0;
  while(epochs < net[/* config */1][/* maxEpochs */2] && error > net[/* config */1][/* targetError */3]) {
    var thisError = trainEpoch(net, data);
    epochs = epochs + 1 | 0;
    error = thisError;
    console.log("Epoch " + Pervasives.string_of_int(epochs) + ": error is " + Pervasives.string_of_float(error), "Alpha is " + Pervasives.string_of_float(net[/* config */1][/* alpha */8]));
  };
  return net;
}

var data = makeSingleValFunctionData((function (inp) {
        return Math.abs(Math.sin(inp));
      }), -5.0, 5.0, 500);

var config = /* record */[
  /* shuffle : true */1,
  /* gradientClip */10000.0,
  /* maxEpochs */10000,
  /* targetError */0.1,
  /* gamma */0.5,
  /* batchSize */100,
  /* decreasedErrorAlpha */1.05,
  /* increasedErrorAlpha */0.5,
  /* alpha */0.001
];

var myNet = makeNetwork(config, softplus, /* :: */[
      15,
      /* :: */[
        15,
        /* :: */[
          1,
          /* [] */0
        ]
      ]
    ]);

setLayerTransfer(myNet, 2, linear);

trainNetwork(myNet, data);

var reluNegGrad = 0.01;

exports.seed                       = seed;
exports.makeWeights                = makeWeights;
exports.softplus                   = softplus;
exports.reluNegGrad                = reluNegGrad;
exports.relu                       = relu;
exports.linear                     = linear;
exports.tanhAct                    = tanhAct;
exports.sum                        = sum;
exports.makePerceptron             = makePerceptron;
exports.recursivelyMakePerceptrons = recursivelyMakePerceptrons;
exports.makeNetwork                = makeNetwork;
exports.calcOutput                 = calcOutput$1;
exports.setInputs                  = setInputs;
exports.WrongNodeType              = WrongNodeType;
exports.calcError                  = calcError;
exports.logOutput                  = logOutput;
exports.logWeights                 = logWeights;
exports.DimensionMismatch          = DimensionMismatch;
exports.leftPad                    = leftPad;
exports.logLinearObj               = logLinearObj;
exports.linearAdd                  = linearAdd;
exports.linearScalarProd           = linearScalarProd;
exports.linearClip                 = linearClip;
exports.sumDerivs                  = sumDerivs;
exports.errorDerivs                = errorDerivs;
exports.updateWeights              = updateWeights;
exports.sample                     = sample;
exports.makeSingleValFunctionData  = makeSingleValFunctionData;
exports.trainExample               = trainExample;
exports.shuffleArray               = shuffleArray;
exports.trainMiniBatch             = trainMiniBatch;
exports.trainEpoch                 = trainEpoch;
exports.setLayerTransfer           = setLayerTransfer;
exports.trainNetwork               = trainNetwork;
exports.data                       = data;
exports.config                     = config;
exports.myNet                      = myNet;
/* seed Not a pure module */

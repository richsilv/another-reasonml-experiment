// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List            = require("bs-platform/lib/js/list.js");
var $$Array         = require("bs-platform/lib/js/array.js");
var Block           = require("bs-platform/lib/js/block.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Random          = require("bs-platform/lib/js/random.js");
var Caml_array      = require("bs-platform/lib/js/caml_array.js");
var Caml_float      = require("bs-platform/lib/js/caml_float.js");
var Caml_int32      = require("bs-platform/lib/js/caml_int32.js");
var Pervasives      = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var seed = (parseInt(Math.random() * Number.MAX_SAFE_INTEGER));

Random.init(seed);

function makeWeights(length) {
  return $$Array.map((function () {
                return Random.$$float(1.0);
              }), Caml_array.caml_make_vect(length, 0.0));
}

function relu_000(inp) {
  return Math.log(1.0 + Math.exp(inp));
}

function relu_001(inp) {
  return 1.0 / (1.0 + Math.exp(-inp));
}

var relu = /* record */[
  relu_000,
  relu_001
];

function linear_000(inp) {
  return inp;
}

function linear_001() {
  return 1.0;
}

var linear = /* record */[
  linear_000,
  linear_001
];

function tanhAct_000(inp) {
  return Math.tanh(inp);
}

function tanhAct_001(inp) {
  return 1.0 - Math.pow(Math.tanh(inp), 2.0);
}

var tanhAct = /* record */[
  tanhAct_000,
  tanhAct_001
];

function sum(arr) {
  return $$Array.fold_right((function (x, y) {
                return x + y;
              }), arr, 0.0);
}

function calcOutput(perc) {
  var match = perc[/* invalid */4];
  if (match !== 0) {
    perc[/* output */3] = Curry._1(perc[/* transfer */6][/* func */0], $$Array.fold_right((function (x, y) {
                return x + y;
              }), $$Array.mapi((function (ind, inputNode) {
                    if (inputNode.tag) {
                      return inputNode[0] * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    } else {
                      return calcOutput(inputNode[0]) * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    }
                  }), perc[/* inputNodes */0]), 0.0));
    perc[/* invalid */4] = /* false */0;
    var match$1 = perc[/* outputNodes */1];
    if (match$1.tag) {
      perc[/* outputNodes */1] = /* Output */Block.__(1, [perc[/* output */3]]);
    }
    return perc[/* output */3];
  } else {
    return perc[/* output */3];
  }
}

function makePerceptron(inputs, transfer) {
  var perc = /* record */[
    /* inputNodes */$$Array.append(inputs, /* array */[/* Input */Block.__(1, [1.0])]),
    /* outputNodes : Output */Block.__(1, [0.0]),
    /* weights */makeWeights(inputs.length + 1 | 0),
    /* output */0.0,
    /* invalid : true */1,
    /* dEdN */0.0,
    /* transfer */transfer
  ];
  $$Array.iter((function (thisPerc) {
          if (thisPerc.tag) {
            return /* () */0;
          } else {
            var thisThisPerc = thisPerc[0];
            var match = thisThisPerc[/* outputNodes */1];
            var tmp;
            tmp = match.tag ? /* Perceptrons */Block.__(0, [/* array */[perc]]) : /* Perceptrons */Block.__(0, [$$Array.append(match[0], /* array */[perc])]);
            thisThisPerc[/* outputNodes */1] = tmp;
            return /* () */0;
          }
        }), inputs);
  return perc;
}

function recursivelyMakeNetwork(transfer, _shape, _net) {
  while(true) {
    var net = _net;
    var shape = _shape;
    var inputs;
    if (net) {
      var net$1 = net[0];
      inputs = $$Array.map((function (perc) {
              return /* Perceptron */Block.__(0, [perc]);
            }), Caml_array.caml_array_get(net$1, net$1.length - 1 | 0));
    } else {
      inputs = Caml_array.caml_make_vect(List.hd(shape), /* Input */Block.__(1, [0.0]));
    }
    var existing = net ? net[0] : /* array */[];
    if (shape) {
      _net = /* Some */[$$Array.append(existing, /* array */[$$Array.map((function(inputs){
                  return function () {
                    return makePerceptron(inputs, transfer);
                  }
                  }(inputs)), Caml_array.caml_make_vect(shape[0], 0))])];
      _shape = shape[1];
      continue ;
      
    } else {
      return existing;
    }
  };
}

function makeNetwork(tranfer, shape) {
  return recursivelyMakeNetwork(tranfer, shape, /* None */0);
}

function calcOutput$1(net) {
  var outputLayer = Caml_array.caml_array_get(net, net.length - 1 | 0);
  return $$Array.map(calcOutput, outputLayer);
}

function setInputs(net, inputs) {
  var inputLayer = Caml_array.caml_array_get(net, 0);
  $$Array.iter((function (perc) {
          perc[/* inputNodes */0] = inputs;
          if ($$Array.fold_right((function (input, allFloats) {
                    return input.tag ? allFloats : /* false */0;
                  }), inputs, /* true */1)) {
            $$Array.map((function (perc) {
                    perc[/* weights */2] = $$Array.sub(perc[/* weights */2], 0, inputs.length);
                    return /* () */0;
                  }), inputLayer);
            return /* () */0;
          } else {
            console.log("WARNING - you are connecting perceptrons rather than values as network inputs");
            return /* () */0;
          }
        }), inputLayer);
  $$Array.iter((function (layer) {
          return $$Array.iter((function (perc) {
                        perc[/* invalid */4] = /* true */1;
                        return /* () */0;
                      }), layer);
        }), net);
  return net;
}

var WrongNodeType = Caml_exceptions.create("Demo-MyFirstApp.WrongNodeType");

function calcError(net, expectedOutput) {
  var outputs = calcOutput$1(net);
  return 0.5 * sum($$Array.mapi((function (ind, thisOutput) {
                    if (thisOutput.tag) {
                      return Math.pow(thisOutput[0] - Caml_array.caml_array_get(outputs, ind), 2.0);
                    } else {
                      throw [
                            WrongNodeType,
                            "Perceptron"
                          ];
                    }
                  }), expectedOutput));
}

function logOutput(net) {
  console.log("Inputs");
  $$Array.iter((function (inputNode) {
          if (inputNode.tag) {
            console.log(inputNode[0]);
            return /* () */0;
          } else {
            console.log("Perceptron");
            return /* () */0;
          }
        }), Caml_array.caml_array_get(Caml_array.caml_array_get(net, 0), 0)[/* inputNodes */0]);
  return $$Array.mapi((function (ind, layer) {
                console.log("Layer " + Pervasives.string_of_int(ind));
                return $$Array.map((function (perc) {
                              console.log(perc[/* output */3]);
                              return /* () */0;
                            }), layer);
              }), net);
}

function logWeights(net) {
  $$Array.mapi((function (ind, layer) {
          console.log("Layer " + Pervasives.string_of_int(ind));
          return $$Array.map((function (perc) {
                        console.log(perc[/* weights */2]);
                        return /* () */0;
                      }), layer);
        }), net);
  return /* () */0;
}

var DimensionMismatch = Caml_exceptions.create("Demo-MyFirstApp.DimensionMismatch");

function leftPad(s, indent) {
  var retString = s;
  for(var _for = 0; _for <= indent; ++_for){
    retString = " " + retString;
  }
  return retString;
}

function logLinearObj(obj, indent) {
  if (obj.tag) {
    return $$Array.iteri((function (ind, innerObj) {
                  console.log(leftPad(Pervasives.string_of_int(ind), indent));
                  return logLinearObj(innerObj, indent + 2 | 0);
                }), obj[0]);
  } else {
    console.log(leftPad($$Array.fold_left((function (output, x) {
                    return output + " " + Pervasives.string_of_float(x);
                  }), leftPad("", indent), obj[0]), indent));
    return /* () */0;
  }
}

function linearAdd(a, b) {
  if (a.tag) {
    if (b.tag) {
      var n = b[0];
      return /* Matrix */Block.__(1, [$$Array.mapi((function (ind, entry) {
                        return linearAdd(entry, Caml_array.caml_array_get(n, ind));
                      }), a[0])]);
    } else {
      throw [
            DimensionMismatch,
            "Objects do not have the same dimensions"
          ];
    }
  } else {
    var u = a[0];
    if (b.tag) {
      throw [
            DimensionMismatch,
            "Objects do not have the same dimensions"
          ];
    } else {
      return /* Vector */Block.__(0, [$$Array.mapi((function (ind, entry) {
                        return entry + Caml_array.caml_array_get(u, ind);
                      }), b[0])]);
    }
  }
}

function linearScalarProd(a, p) {
  if (a.tag) {
    return /* Matrix */Block.__(1, [$$Array.map((function (entry) {
                      return linearScalarProd(entry, p);
                    }), a[0])]);
  } else {
    return /* Vector */Block.__(0, [$$Array.map((function (entry) {
                      return entry * p;
                    }), a[0])]);
  }
}

function linearClip(clipLimit, obj) {
  if (obj.tag) {
    return /* Matrix */Block.__(1, [$$Array.map((function (param) {
                      return linearClip(clipLimit, param);
                    }), obj[0])]);
  } else {
    return /* Vector */Block.__(0, [$$Array.map((function (x) {
                      return Caml_float.caml_copysign_float(Pervasives.min(clipLimit, Math.abs(x)), x);
                    }), obj[0])]);
  }
}

function sumDerivs(derivs) {
  return List.fold_right(linearAdd, List.tl(derivs), List.hd(derivs));
}

function errorDerivs(net, expectedOutput) {
  var reversed = $$Array.of_list(List.rev($$Array.to_list(net)));
  return /* Matrix */Block.__(1, [$$Array.of_list(List.rev($$Array.to_list($$Array.map((function (layer) {
                                return /* Matrix */Block.__(1, [$$Array.mapi((function (ind, perc) {
                                                  var match = perc[/* outputNodes */1];
                                                  var dEdO;
                                                  if (match.tag) {
                                                    var thisExpectedOutput = Caml_array.caml_array_get(expectedOutput, ind);
                                                    if (thisExpectedOutput.tag) {
                                                      dEdO = match[0] - thisExpectedOutput[0];
                                                    } else {
                                                      throw [
                                                            WrongNodeType,
                                                            "Perceptron"
                                                          ];
                                                    }
                                                  } else {
                                                    dEdO = sum($$Array.mapi((function (innerInd, innerPerc) {
                                                                return innerPerc[/* dEdN */5] * Caml_array.caml_array_get(innerPerc[/* weights */2], innerInd);
                                                              }), match[0]));
                                                  }
                                                  var dOdN = Curry._1(perc[/* transfer */6][/* deriv */1], perc[/* output */3]);
                                                  perc[/* dEdN */5] = dEdO * dOdN;
                                                  return /* Vector */Block.__(0, [$$Array.map((function (input) {
                                                                    var tmp;
                                                                    tmp = input.tag ? input[0] : input[0][/* output */3];
                                                                    return perc[/* dEdN */5] * tmp;
                                                                  }), perc[/* inputNodes */0])]);
                                                }), layer)]);
                              }), reversed))))]);
}

function updateWeights(net, update) {
  if (update.tag) {
    $$Array.mapi((function (indA, layer) {
            if (layer.tag) {
              $$Array.mapi((function (indB, percEntry) {
                      if (percEntry.tag) {
                        throw [
                              DimensionMismatch,
                              "Object does not have the right number of dimensions"
                            ];
                      } else {
                        $$Array.mapi((function (indC, weightUpdate) {
                                var perc = Caml_array.caml_array_get(Caml_array.caml_array_get(net, indA), indB);
                                var currentWeight = Caml_array.caml_array_get(perc[/* weights */2], indC);
                                Caml_array.caml_array_set(perc[/* weights */2], indC, currentWeight - weightUpdate);
                                var match = perc[/* outputNodes */1];
                                if (match.tag) {
                                  return /* () */0;
                                } else {
                                  $$Array.map((function (outputPerc) {
                                          outputPerc[/* invalid */4] = /* true */1;
                                          return /* () */0;
                                        }), match[0]);
                                  return /* () */0;
                                }
                              }), percEntry[0]);
                        return /* () */0;
                      }
                    }), layer[0]);
              return /* () */0;
            } else {
              throw [
                    DimensionMismatch,
                    "Object does not have the right number of dimensions"
                  ];
            }
          }), update[0]);
    return /* () */0;
  } else {
    throw [
          DimensionMismatch,
          "Object does not have the right number of dimensions"
        ];
  }
}

function sample(min, max) {
  return Random.$$float(max - min) + min;
}

function makeSingleValFunctionData(f, min, max, number) {
  var examples = /* [] */0;
  for(var _for = 0; _for <= number; ++_for){
    var input = sample(min, max);
    examples = /* :: */[
      /* tuple */[
        /* array */[/* Input */Block.__(1, [input])],
        /* array */[/* Output */Block.__(1, [Curry._1(f, input)])]
      ],
      examples
    ];
  }
  return examples;
}

function trainExample(net, errorData, example) {
  var outputs = example[1];
  setInputs(net, example[0]);
  calcOutput$1(net);
  var error = calcError(net, outputs);
  var derivs = errorDerivs(net, outputs);
  if (errorData) {
    var errorDataSoFar = errorData[0];
    return /* tuple */[
            linearAdd(errorDataSoFar[0], derivs),
            error + errorDataSoFar[1]
          ];
  } else {
    return /* tuple */[
            derivs,
            error
          ];
  }
}

function shuffleArray(a) {
  var b = $$Array.copy(a);
  $$Array.fast_sort((function (_, _$1) {
          return Random.$$int(2) - 1 | 0;
        }), b);
  return b;
}

function trainMiniBatch(config, net, data, prevWeightDerivs) {
  var errorData = List.fold_left((function (errorSoFar, example) {
          return /* Some */[trainExample(net, errorSoFar, example)];
        }), /* None */0, data);
  if (errorData) {
    var errorData$1 = errorData[0];
    var weightDerivs = errorData$1[0];
    var weightUpdate = prevWeightDerivs ? linearClip(config[/* gradientClip */1], linearAdd(linearScalarProd(prevWeightDerivs[0], config[/* gamma */5]), linearScalarProd(weightDerivs, config[/* alpha */4]))) : linearClip(config[/* gradientClip */1], linearScalarProd(weightDerivs, config[/* alpha */4]));
    updateWeights(net, weightUpdate);
    return /* tuple */[
            errorData$1[1],
            /* Some */[weightUpdate]
          ];
  } else {
    return /* tuple */[
            0.0,
            /* None */0
          ];
  }
}

function trainEpoch(config, net, data, epochPrevWeightDerivs) {
  var match = config[/* shuffle */0];
  var finalDataArray = match !== 0 ? shuffleArray($$Array.of_list(data)) : $$Array.of_list(data);
  var dataLength = finalDataArray.length;
  var match$1 = config[/* batchSize */6];
  var miniBatchSize = match$1 !== 0 ? config[/* batchSize */6] : dataLength;
  var match$2 = $$Array.fold_left((function (iterDetails, _) {
          var lastIndex = iterDetails[2];
          var thisBatchSize = Pervasives.min(miniBatchSize, dataLength - lastIndex | 0);
          var match = trainMiniBatch(config, net, $$Array.to_list($$Array.sub(finalDataArray, lastIndex, thisBatchSize)), iterDetails[1]);
          var newError = iterDetails[0] + match[0];
          return /* tuple */[
                  newError,
                  match[1],
                  lastIndex + thisBatchSize | 0
                ];
        }), /* tuple */[
        0.0,
        epochPrevWeightDerivs,
        0
      ], Caml_array.caml_make_vect(1 + Caml_int32.div(dataLength, miniBatchSize) | 0, 0));
  return /* tuple */[
          match$2[0],
          match$2[1]
        ];
}

function setLayerTransfer(net, layerInd, transfer) {
  $$Array.map((function (perc) {
          perc[/* transfer */6] = transfer;
          return /* () */0;
        }), Caml_array.caml_array_get(net, layerInd));
  return /* () */0;
}

function trainNetwork(config, net, data) {
  var error = config[/* targetError */3] + 1.0;
  var epochs = 0;
  var prevWeightDerivs = /* None */0;
  while(epochs < config[/* maxEpochs */2] && error > config[/* targetError */3]) {
    var match = trainEpoch(config, net, data, prevWeightDerivs);
    epochs = epochs + 1 | 0;
    error = match[0];
    prevWeightDerivs = match[1];
    console.log("Epoch " + Pervasives.string_of_int(epochs) + ": error is " + Pervasives.string_of_float(error));
  };
  return net;
}

var myNet = recursivelyMakeNetwork(relu, /* :: */[
      5,
      /* :: */[
        1,
        /* [] */0
      ]
    ], /* None */0);

setLayerTransfer(myNet, 1, linear);

var data = makeSingleValFunctionData((function (inp) {
        return Math.abs(Math.sin(inp));
      }), -5.0, 5.0, 500);

var config = /* record */[
  /* shuffle : true */1,
  /* gradientClip */10000.0,
  /* maxEpochs */1000,
  /* targetError */0.1,
  /* alpha */0.001,
  /* gamma */0.3,
  /* batchSize */50
];

trainNetwork(config, myNet, data);

exports.seed                      = seed;
exports.makeWeights               = makeWeights;
exports.relu                      = relu;
exports.linear                    = linear;
exports.tanhAct                   = tanhAct;
exports.sum                       = sum;
exports.makePerceptron            = makePerceptron;
exports.recursivelyMakeNetwork    = recursivelyMakeNetwork;
exports.makeNetwork               = makeNetwork;
exports.calcOutput                = calcOutput$1;
exports.setInputs                 = setInputs;
exports.WrongNodeType             = WrongNodeType;
exports.calcError                 = calcError;
exports.logOutput                 = logOutput;
exports.logWeights                = logWeights;
exports.DimensionMismatch         = DimensionMismatch;
exports.leftPad                   = leftPad;
exports.logLinearObj              = logLinearObj;
exports.linearAdd                 = linearAdd;
exports.linearScalarProd          = linearScalarProd;
exports.linearClip                = linearClip;
exports.sumDerivs                 = sumDerivs;
exports.errorDerivs               = errorDerivs;
exports.updateWeights             = updateWeights;
exports.sample                    = sample;
exports.makeSingleValFunctionData = makeSingleValFunctionData;
exports.trainExample              = trainExample;
exports.shuffleArray              = shuffleArray;
exports.trainMiniBatch            = trainMiniBatch;
exports.trainEpoch                = trainEpoch;
exports.setLayerTransfer          = setLayerTransfer;
exports.trainNetwork              = trainNetwork;
exports.myNet                     = myNet;
exports.data                      = data;
exports.config                    = config;
/* seed Not a pure module */

// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List            = require("bs-platform/lib/js/list.js");
var $$Array         = require("bs-platform/lib/js/array.js");
var Block           = require("bs-platform/lib/js/block.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Random          = require("bs-platform/lib/js/random.js");
var Caml_array      = require("bs-platform/lib/js/caml_array.js");
var Pervasives      = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

function makeWeights(length) {
  return $$Array.map((function () {
                return Random.$$float(1.0);
              }), Caml_array.caml_make_vect(length, 0.0));
}

function relu_000(inp) {
  return Math.log(1.0 + Math.exp(inp));
}

function relu_001(inp) {
  return 1.0 / (1.0 + Math.exp(-inp));
}

var relu = /* record */[
  relu_000,
  relu_001
];

function sum(arr) {
  return $$Array.fold_right((function (x, y) {
                return x + y;
              }), arr, 0.0);
}

function calcOutput(perc) {
  var match = perc[/* invalid */4];
  if (match !== 0) {
    perc[/* output */3] = Curry._1(perc[/* transfer */6][/* func */0], $$Array.fold_right((function (x, y) {
                return x + y;
              }), $$Array.mapi((function (ind, inputNode) {
                    if (inputNode.tag) {
                      return inputNode[0] * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    } else {
                      return calcOutput(inputNode[0]) * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    }
                  }), perc[/* inputNodes */0]), 0.0));
    perc[/* invalid */4] = /* false */0;
    var match$1 = perc[/* outputNodes */1];
    if (match$1.tag) {
      perc[/* outputNodes */1] = /* Output */Block.__(1, [perc[/* output */3]]);
    }
    return perc[/* output */3];
  } else {
    return perc[/* output */3];
  }
}

function makePerceptron(inputs) {
  var perc = /* record */[
    /* inputNodes */$$Array.append(inputs, /* array */[/* Input */Block.__(1, [1.0])]),
    /* outputNodes : Output */Block.__(1, [0.0]),
    /* weights */makeWeights(inputs.length + 1 | 0),
    /* output */0.0,
    /* invalid : true */1,
    /* dEdN */0.0,
    /* transfer */relu
  ];
  $$Array.iter((function (thisPerc) {
          if (thisPerc.tag) {
            return /* () */0;
          } else {
            var thisThisPerc = thisPerc[0];
            var match = thisThisPerc[/* outputNodes */1];
            var tmp;
            tmp = match.tag ? /* Perceptrons */Block.__(0, [/* array */[perc]]) : /* Perceptrons */Block.__(0, [$$Array.append(match[0], /* array */[perc])]);
            thisThisPerc[/* outputNodes */1] = tmp;
            return /* () */0;
          }
        }), inputs);
  return perc;
}

function recursivelyMakeNetwork(_shape, _net) {
  while(true) {
    var net = _net;
    var shape = _shape;
    var inputs;
    if (net) {
      var net$1 = net[0];
      inputs = $$Array.map((function (perc) {
              return /* Perceptron */Block.__(0, [perc]);
            }), Caml_array.caml_array_get(net$1, net$1.length - 1 | 0));
    } else {
      inputs = Caml_array.caml_make_vect(List.hd(shape), /* Input */Block.__(1, [0.0]));
    }
    var existing = net ? net[0] : /* array */[];
    if (shape) {
      _net = /* Some */[$$Array.append(existing, /* array */[$$Array.map((function(inputs){
                  return function () {
                    return makePerceptron(inputs);
                  }
                  }(inputs)), Caml_array.caml_make_vect(shape[0], 0))])];
      _shape = shape[1];
      continue ;
      
    } else {
      return existing;
    }
  };
}

function makeNetwork(shape) {
  return recursivelyMakeNetwork(shape, /* None */0);
}

function calcOutput$1(net) {
  var outputLayer = Caml_array.caml_array_get(net, net.length - 1 | 0);
  return $$Array.map(calcOutput, outputLayer);
}

function setInputs(net, inputs) {
  var inputLayer = Caml_array.caml_array_get(net, 0);
  $$Array.iter((function (perc) {
          perc[/* inputNodes */0] = inputs;
          return /* () */0;
        }), inputLayer);
  $$Array.iter((function (layer) {
          return $$Array.iter((function (perc) {
                        perc[/* invalid */4] = /* true */1;
                        return /* () */0;
                      }), layer);
        }), net);
  return net;
}

function calcError(net, expectedOutput) {
  var outputs = calcOutput$1(net);
  return 0.5 * sum($$Array.mapi((function (ind, output) {
                    return Math.pow(Caml_array.caml_array_get(expectedOutput, ind) - output, 2.0);
                  }), outputs));
}

function logOutput(net) {
  console.log("Inputs");
  $$Array.iter((function (inputNode) {
          if (inputNode.tag) {
            console.log(inputNode[0]);
            return /* () */0;
          } else {
            console.log("Perceptron");
            return /* () */0;
          }
        }), Caml_array.caml_array_get(Caml_array.caml_array_get(net, 0), 0)[/* inputNodes */0]);
  return $$Array.mapi((function (ind, layer) {
                console.log("Layer " + Pervasives.string_of_int(ind));
                return $$Array.map((function (perc) {
                              console.log(perc[/* output */3]);
                              return /* () */0;
                            }), layer);
              }), net);
}

var DimensionMismatch = Caml_exceptions.create("Demo-MyFirstApp.DimensionMismatch");

function linearAdd(a, b) {
  if (a.tag) {
    if (b.tag) {
      var n = b[0];
      return /* Matrix */Block.__(1, [$$Array.mapi((function (ind, entry) {
                        return linearAdd(entry, Caml_array.caml_array_get(n, ind));
                      }), a[0])]);
    } else {
      throw [
            DimensionMismatch,
            "Objects do not have the same dimensions"
          ];
    }
  } else {
    var u = a[0];
    if (b.tag) {
      throw [
            DimensionMismatch,
            "Objects do not have the same dimensions"
          ];
    } else {
      return /* Vector */Block.__(0, [$$Array.mapi((function (ind, entry) {
                        return entry + Caml_array.caml_array_get(u, ind);
                      }), b[0])]);
    }
  }
}

function sumDerivs(derivs) {
  return List.fold_right(linearAdd, List.tl(derivs), List.hd(derivs));
}

function errorDerivs(net, expectedOutput) {
  var reversed = $$Array.of_list(List.rev($$Array.to_list(net)));
  return /* Matrix */Block.__(1, [$$Array.map((function (layer) {
                    return /* Matrix */Block.__(1, [$$Array.mapi((function (ind, perc) {
                                      var match = perc[/* outputNodes */1];
                                      var dEdO;
                                      dEdO = match.tag ? match[0] - Caml_array.caml_array_get(expectedOutput, ind) : sum($$Array.mapi((function (innerInd, innerPerc) {
                                                    return innerPerc[/* dEdN */5] * Caml_array.caml_array_get(innerPerc[/* weights */2], innerInd);
                                                  }), match[0]));
                                      var dOdN = Curry._1(perc[/* transfer */6][/* deriv */1], perc[/* output */3]);
                                      perc[/* dEdN */5] = dEdO * dOdN;
                                      return /* Vector */Block.__(0, [$$Array.map((function (input) {
                                                        var tmp;
                                                        tmp = input.tag ? input[0] : input[0][/* output */3];
                                                        return perc[/* dEdN */5] * tmp;
                                                      }), perc[/* inputNodes */0])]);
                                    }), layer)]);
                  }), reversed)]);
}

function updateWeights(net, errorDerivs, alpha) {
  if (errorDerivs.tag) {
    $$Array.mapi((function (indA, layer) {
            if (layer.tag) {
              $$Array.mapi((function (indB, percEntry) {
                      if (percEntry.tag) {
                        throw [
                              DimensionMismatch,
                              "Object does not have the right number of dimensions"
                            ];
                      } else {
                        $$Array.mapi((function (indC, weightError) {
                                var perc = Caml_array.caml_array_get(Caml_array.caml_array_get(net, indA), indB);
                                var currentWeight = Caml_array.caml_array_get(perc[/* weights */2], indC);
                                return Caml_array.caml_array_set(perc[/* weights */2], indC, currentWeight + alpha * weightError);
                              }), percEntry[0]);
                        return /* () */0;
                      }
                    }), layer[0]);
              return /* () */0;
            } else {
              throw [
                    DimensionMismatch,
                    "Object does not have the right number of dimensions"
                  ];
            }
          }), errorDerivs[0]);
    return /* () */0;
  } else {
    throw [
          DimensionMismatch,
          "Object does not have the right number of dimensions"
        ];
  }
}

var myNet = recursivelyMakeNetwork(/* :: */[
      2,
      /* :: */[
        3,
        /* :: */[
          2,
          /* [] */0
        ]
      ]
    ], /* None */0);

setInputs(myNet, /* array */[
      /* Input */Block.__(1, [0.4]),
      /* Input */Block.__(1, [0.2])
    ]);

calcOutput$1(myNet);

logOutput(myNet);

console.log("===============");

console.log(calcError(myNet, /* float array */[
          3.5,
          2.9
        ]));

var derivs = errorDerivs(myNet, /* float array */[
      1.8,
      1.2
    ]);

updateWeights(myNet, derivs, 1.0);

calcOutput$1(myNet);

logOutput(myNet);

exports.makeWeights            = makeWeights;
exports.relu                   = relu;
exports.sum                    = sum;
exports.makePerceptron         = makePerceptron;
exports.recursivelyMakeNetwork = recursivelyMakeNetwork;
exports.makeNetwork            = makeNetwork;
exports.calcOutput             = calcOutput$1;
exports.setInputs              = setInputs;
exports.calcError              = calcError;
exports.logOutput              = logOutput;
exports.DimensionMismatch      = DimensionMismatch;
exports.linearAdd              = linearAdd;
exports.sumDerivs              = sumDerivs;
exports.errorDerivs            = errorDerivs;
exports.updateWeights          = updateWeights;
exports.myNet                  = myNet;
exports.derivs                 = derivs;
/* myNet Not a pure module */

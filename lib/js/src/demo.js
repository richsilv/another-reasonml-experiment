// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var $$Array    = require("bs-platform/lib/js/array.js");
var Block      = require("bs-platform/lib/js/block.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Random     = require("bs-platform/lib/js/random.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");

function makeWeights(length) {
  return $$Array.map((function () {
                return Random.$$float(1.0);
              }), Caml_array.caml_make_vect(length, 0.0));
}

function relu(inp) {
  return Math.log(1.0 + Math.exp(inp));
}

function calcOutput(perc) {
  var match = perc[/* invalid */4];
  if (match !== 0) {
    perc[/* output */3] = Curry._1(perc[/* transfer */5], $$Array.fold_right((function (x, y) {
                return x + y;
              }), $$Array.mapi((function (ind, inputNode) {
                    if (inputNode.tag) {
                      return inputNode[0] * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    } else {
                      return calcOutput(inputNode[0]) * Caml_array.caml_array_get(perc[/* weights */2], ind);
                    }
                  }), perc[/* inputNodes */0]), 0.0));
    perc[/* invalid */4] = /* false */0;
    var match$1 = perc[/* outputNodes */1];
    if (match$1.tag) {
      perc[/* outputNodes */1] = /* Output */Block.__(1, [perc[/* output */3]]);
    }
    return perc[/* output */3];
  } else {
    return perc[/* output */3];
  }
}

function makePerceptron(inputs) {
  var perc = /* record */[
    /* inputNodes */inputs,
    /* outputNodes : Output */Block.__(1, [0.0]),
    /* weights */makeWeights(inputs.length),
    /* output */0.0,
    /* invalid : false */0,
    /* transfer */relu
  ];
  $$Array.map((function (thisPerc) {
          if (thisPerc.tag) {
            return /* () */0;
          } else {
            var thisThisPerc = thisPerc[0];
            var match = thisThisPerc[/* outputNodes */1];
            var tmp;
            tmp = match.tag ? /* Perceptrons */Block.__(0, [/* array */[perc]]) : /* Perceptrons */Block.__(0, [$$Array.append(match[0], /* array */[perc])]);
            thisThisPerc[/* outputNodes */1] = tmp;
            return /* () */0;
          }
        }), inputs);
  return perc;
}

function makeNetworkRecursive(shape, net) {
  if (net) {
    var net$1 = net[0];
    $$Array.map((function (perc) {
            return /* Perceptron */Block.__(0, [perc]);
          }), Caml_array.caml_array_get(net$1, net$1.length - 1 | 0));
  } else {
    Caml_array.caml_make_vect(List.hd(shape), /* Input */Block.__(1, [0.0]));
  }
  if (shape) {
    return 2.0;
  } else {
    return 1.0;
  }
}

function makeNetwork(shape) {
  return makeNetworkRecursive(shape, /* None */0);
}

var x = makePerceptron(/* array */[
      /* Input */Block.__(1, [1.0]),
      /* Input */Block.__(1, [2.0])
    ]);

var y = makePerceptron(/* array */[
      /* Input */Block.__(1, [1.0]),
      /* Input */Block.__(1, [2.0])
    ]);

var z = makePerceptron(/* array */[
      /* Perceptron */Block.__(0, [x]),
      /* Perceptron */Block.__(0, [y])
    ]);

console.log(calcOutput(z));

exports.makeWeights          = makeWeights;
exports.relu                 = relu;
exports.calcOutput           = calcOutput;
exports.makePerceptron       = makePerceptron;
exports.makeNetworkRecursive = makeNetworkRecursive;
exports.makeNetwork          = makeNetwork;
exports.x                    = x;
exports.y                    = y;
exports.z                    = z;
/* x Not a pure module */
